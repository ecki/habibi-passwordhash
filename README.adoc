= Habibi a PBKDF2 based password hash format
Bernd Eckenfels
v0.1, 2017-03-19
:description: Draf Specification for a password hashing format based on PBKDF2 with conditioning and peppering.
:!compat-mode:
:keywords: password-hash, security, specification, PBKDF2, HMAC, SHA-3, SHA-3
:page-description: {description}
:page-keywords: {keywords}
:icons: font
:idprefix:
:idseparator:
:sectanchors:
:mdash: &#8212;
:defaultiterations: 20000

{description}

.Draft
****
*This document is only a draft.
These recommendations are not doctrine and are subject to change.*
Sent your comments to bernd-2017 (@) eckenfels.net
****

== Introduction

Password hashes based on PBKDF2 are still in high demand.
The main reason for this is, that NIST endorsed PBKDF2 with HMAC in http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf[SP 800-132 (PDF)] for key derivation (w/ brute-force resistance).
And the draft for the upcoming NIST https://pages.nist.gov/800-63-3/sp800-63b.html[SP 800-63B] _Digital Identity Guidelines: Authentication and Lifecycle Management_ mentions PBKDF2 as a password-hash.
The hash also recommends to use a seperately stored secret (and mentions HMac).

[quote,NIST,SP 800-63b]
Verifiers SHALL store memorized secrets in a form that is resistant to offline attacks.
Secrets SHALL be hashed with a salt value using an approved hash function such as PBKDF2 as described in [SP 800-132].
The salt value SHALL be a 32-bit or longer random value generated by an approved random bit generator and stored along with the hash result.
At least 10,000 iterations of the hash function SHOULD be performed.
A keyed hash function (e.g., HMAC [FIPS198-1]), with the key stored separately from the hashed authenticators (e.g., in a hardware security module) SHOULD be used to further resist dictionary attacks against the stored hashed authenticators.

This repository collects the definition for a interoperable password hash format based on PBKDF2, specifically compatible with above definition.
The format is intentionally restricted in variations as it can easily be replaced by a new prefix instead of making the parsing and generation too complex.

=== Alternatives

There are many advanced password hashing schemes out there, this specification does not try to compete.
If you are looking for a memory-hard alternative you are much better off with https://www.tarsnap.com/scrypt.html[_scrypt_] or https://password-hashing.net/#argon2[_ARGON2_].

If you look for a alternative with a wide range of operating system support https://en.wikipedia.org/wiki/Bcrypt[_bcrypt_] is probably your friend, since none of the normal password hashing schemes supported by unixoide `crypt()` have a comparable resistance against brute-forcing.

However if you care for approved cryptographic methods and some form of standards endoresement, then _PBKDF2_ is probably your best friend.

=== Password Securiy

The fact that this is a pretty current specification is by no means an endorsemet for password based authentication.
Memorized secets have all kinds of issues in practice wich makes them a huge security problem.
So consider alternatives or multple factors if you care for the security of your service and your users.
However since passwords cannot fully be avoided, you at least should store them with some level of protection.

Password hashing can not defend against overly weak passwords.
You should enfore a minimum complexity aproperiate for your service.

Since you are here for the conformance to NIST you should go all the way and follow the new _Special Publication 800-63-3: Digital Authentication Guidelines and related documents_: minimum length of passwords should be 8 ASCII or Unicode characters with no composition rules.
You can read this https://www.cisoadvisory.com/cai-blog/2016/10/24/nist-proposes-new-approach-to-passwords[summary].

And make sure to check for dictionary passwords (this repository will offer a solution for this as well).

== Properties of this Password-Hashing Scheme

* Uses PBKDF2 (https://tools.ietf.org/html/rfc2898#section-5.2[RFC 2898]) with HMac (https://tools.ietf.org/html/rfc2104[RFC 2104], FIPS 198-1)
** Specifies a variant with SHA2-512 (FIPS 180-4 Section 6.2 - 6.5, https://tools.ietf.org/html/rfc6234[RFC 6234])
** Specifies a variant with SHA3-512 (FIPS 202)
* Supports variable number of iterations, salt bytes and output bytes
* Requires UTF-8 encoding
* Features a pre-conditioning step
* Allows for pepper (seperately stored key)

== Preconditioning

In a distributed system with front-end servers and authenticated servers it is useful if some protections of the password can be done early.
If this does not require a salt to be known/retrieved or access to hardware-secured secrets then this a win.
It also means the early erradication of clear-text (even in memory) opens a number of new applications like cashing the password checking outcome.
The later is especially good in environments where stateless services (with tokens or re-authentication) is used.

In the current draft the underlying hash function is used, as this blends well into the normal preconditioning required for HMAC keys which are longer than the blocksize.
However this is up for discusion: should a faster/different method be used?
(Facebook seems to use a MD5 hash as the outer layer of their password protection).
Using a fast and simple hash like MD5 has the advantage that it could be done even in Javascript.

== String Format

    SHA2-512: $pbkdf2s2$[t=rrr][,keyid=kkkk]$ssssss$hhhhhhhhhhhhhhhh
    SHA3-512: $pbkdf2s3$[t=rrr][,keyid=kkkk]$ssssss$hhhhhhhhhhhhhhhh

The syntax uses the https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md[PHC string format] with two _function symbolic names_ (maximum 10 chars allowed):

* "pbkdf2s2": For a PBKDF2 based on HMac with SHA2-512 with conditioning and optional pepper
* "pbkdf2s3": For a PBKDF2 based on Hmac with SHA3-512 with conditioning and optional pepper

The parameters supported for the format are (in this order):

* t: Number of iterations, between 100 and (2^32)-1. Value is an integer in decimal, over 3 to 10 digits. The parameter is optional, the default value is {defaultiterations}.
* keyId: Binary identifier for a key. Value is a sequence of 0 to 8 bytes, encoded in B64 as 0 to 11 characters. This parameter is optional; the default value means no key.
  The contents of the identifier are chosen by the application and are meant to allow the application to locate the key to use for the pepper step.

The _salt_ is a B64 encoded. It supports salts in the range of 4-32 bytes (6-43 characters). By default a 16 byte salt should be generated. An encoded UUID, or a sequence
of 16 bytes produced with a cryptographically strong PRNG, are appropriate salt values.

The hash output is encoded in B64. Its length shall be between 12 and 64 bytes (16 and 86 characters, respectively). The default output length is 32 bytes (43 characters).
The validation step compares the given bytes starting from the left.

With this rules the total length of the password verifier is between 34 and 171 characters.

Using the prefix `{pbkdf2s2}` and `{pbkdf2s3}` instead of `$pbkdf2s2$` and `$pbkdf2s3ยง` is allowed in scenrios like LDAP attributes which prefer this syntax.

== Algorithm

The following parameters must be defined before generating a password-hash and are dedced from the formatted password-hash string, when verifying:

* saltLen: number of bytes (default 16)
* pepperBytes: a randomly chosen, seperately persisted encryption key or `null` 
* keyId: a binary identifier for the key or `null`
* t: the iteration count (default {defaultiterations})
* hash: SHA2-512 or SHA3-512

.Step 1: Password to Bytes

The first function is to convert the text password into bytes. This must be done using the UTF-8 encoding. It should NOT remove consecutive blanks.
No trimming should be done by the password-hashing library.
Implementations may reject passwords longer than 128 codepoints but should never silently truncate the input.
The implementation must reject passwords containing a NUL char (U+0000).

   passwordBytes = utf8encode(passwordString)

NIST SP 800-63b defines the following:

[quote,NIST,SP 800-63b]
If Unicode characters are accepted in memorized secrets, the verifier SHOULD apply the Normalization Process for Stabilized Strings defined in Section 12.1 of Unicode Standard Annex 15 http://www.unicode.org/reports/tr15/#Stabilized_Strings[[UAX 15]] using either the NFKC or NFKD normalization.
Subscribers choosing memorized secrets containing Unicode characters SHOULD be advised that some characters may be represented differently by some endpoints, which can affect their ability to authenticate successfully.
This process is applied prior to hashing of the byte string representing the memorized secret.

Since normalisation would require additional dependencies, it is recommended that applications do the required NPSS proces, or at least make sure the password source produces normalized strings and reject non-stable codepoints.
The algorithm described here will preserve any normalisation.

The trim() function 

.Step 2: Conditioning

The second stept is to conditon the password. The idea here is to allow infrastructure to do this step early (before sending the passwords to authentication servers).
The function of the conditioning is producing a constant length and effecitvely hiding the clear test password from following steps. It uses the hash function specified
by the symbolic name (SHA2-512 or SHA3-512).

This conditioning is well within the specification for PBKDF2, because the HMAC used requires to hash the key (which is the password in this case) with the hash function
if it is longer as the blocksize.

   conditionedBytes = hash(passwordBytes) // TODO: use HMAC instead?

.Stept 3: Iterated Hashing

The third step does the main work, iteratively applying the PBKDF2 with the hash. This is the same as $pbkdf2$ formats are using.

    saltBytes = generaterandombytes(saltLen)
    hLen = 64 // output length of hash for both variants

    DK = PBKDF( // parameters see http://www.ietf.org/rfc/rfc2898.txt
        PRF = HMAC-SHA2-512 or HMAC-SHA3-512,
        P = conditionedBytes,
        S = saltBytes,
        c = t, // iteration count
        dkLen = hLen) // l = 1; r = 0 TODO

NOTE: iteratively applying Hmacs with SHA-2 can be optimized by precomputing the initial compression function on (K x iPad) and (K x oPad).
This method is well known to attackers and as a defender you  need to use this optimization as well.
This format does not modify the PBKDF2 construct to make it impossible because it explicitely wants to implement the standard.
SHA-3 does not use a https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction[Merkle–Damgård] construction and prevents this shortcut.

.Step 4: Sealing (Peppering)

The next step is optional: if a secret (pepper) is specified it will be used to run another round of HMAC with the given key.
This step is only invoked once, so it can be executed by a relative slow HSM or TPM.

    pepperBytes = read key wit keyid, should be hLen bytes
    sealedBytes = HMAC(key=pepperBytes, DK)

.Stept 5: Output Formatting

The result will be serialized in PHC format with the following method:

    truncLen = 32 // 12 .. 64
    hashBytes = truncate(sealedBytes, truncLen) // or DK if step 5 is skipped

    functionid = "pbkdf2s2" or "pbkdf2s3"

    param1 = (t!=20000) ? "t=" + t : ""
    param2 = (keyId!=null) ? "keyId=" + B64(keyId) : ""
    if (param1 != "" || param2 != "")
      param = ""
      if (param1 != "")
        param += param1
        if (param2 != "")
          param += "," + param2
      else
        if (param2 != "")
          param += param2
    
    hashString = funtionid + param + "$" + B64(salt) + "$" + B64(hashBytes)

When parsing the PHC format to verify the salt and the sealed bytes get base64 parsed and length validated.
