= Habibi a PBKDF2 based password hash format

*This is a draft, sent your comments to bernd-2017 (@) eckenfels.net*

While there are password hash formats like BCRYPT (`$2y$`) or SCRYPT (`$scrypt$`) or the new winner of the password hash competition Argon (`$argon`) password hashes
based on PBKDF2 are still in high demand. The main reason for this is, that NIST endorses PBKDF2 with HMAC and endorsed hash function in SP 800-132 as well as the
draft for the upcoming NIST Special Publication 800­63B _Digital Identity Guidelines: Authentication and Lifecycle Management_ (which is not very clear on the details
but asks for aproved hashes and seperately stored secrets).

This repository collects the definition for a interoperable password hash format based on PBKDF2. The format is intentionally restricted in variations
as it can easily be replaced by a new prefix instead of making the parsing and generation too complex.

== Properties

* Uses PBKDF2 (https://tools.ietf.org/html/rfc2898#section-5.2[RFC 2898]) with HMac (https://tools.ietf.org/html/rfc2104[RFC 2104])
** Specifies a variant with SHA2-512 (FIPS 180-4 Section 6.2 - 6.5, https://tools.ietf.org/html/rfc6234[RFC 6234])
** Specifies a variant with SHA3-512 (FIPS 202)
* Supports variable number of iterations, salt bytes and output bytes
* Requires UTF-8 encoding
* Features a pre-conditioning step
* Allows for pepper (seperately stored key)

== String Format 

    SHA2-512: $pbkdf2s2$[t=rrr][,keyid=kkkk]$ssssss$hhhhhhhhhhhhhhhh
    SHA3-512: $pbkdf2s3$[t=rrr][,keyid=kkkk]$ssssss$hhhhhhhhhhhhhhhh

The syntax uses the https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md[PHC string format] with two _function symbolic names_ (maximum 10 chars allowed):

* "pbkdf2s2": For a PBKDF2 based on HMac with SHA2-512 with conditioning and optional pepper
* "pbkdf2s3": For a PBKDF2 based on Hmac with SHA3-512 with conditioning and optional pepper

The parameters supported for the format are (in this order):

* t: Number of iterations, between 100 and (2^32)-1. Value is an integer in decimal, over 3 to 10 digits. The parameter is optional, the default value is 20000.
* keyid: Binary identifier for a key. Value is a sequence of 0 to 8 bytes, encoded in B64 as 0 to 11 characters. This parameter is optional; the default value means no key. 
  The contents of the identifier are chosen by the application and are meant to allow the application to locate the key to use for the pepper step.
 
The _salt_ is a B64 encoded. It supports salts in the range of 4-32 bytes (6-43 characters). By default a 16 byte salt should be generated. An encoded UUID, or a sequence
of 16 bytes produced with a cryptographically strong PRNG, are appropriate salt values.

The hash output is encoded in B64. Its length shall be between 12 and 64 bytes (16 and 86 characters, respectively). The default output length is 32 bytes (43 characters).
The validation step compares the given bytes starting from the left.

With this rules the total length of the password verifier is between 34 and 171 characters.

Using the prefix `{pbkdf2s2}` and `{pbkdf2s3}` instead of `$pbkdf2s2$` and `$pbkdf2s3§` is allowed in scenrios like LDAP attributes which prefer this syntax.

== Algorithm

.Step 1: Password to Bytes

The first function is to convert the text password into bytes. This must be done using the UTF-8 encoding. It should NOT remove consecutive blanks.
Leading and Trailing blanks must be removed. Implementations may reject passwords longer than 128 codepoints but should never silently truncate the input.
The implementation must reject passwords containing a NUL char (U+0000).

   passwordBytes = utf8encode(trim(passwordString))
  
TODO: Unicode Normalisation (NIST)?

.Step 2: Conditioning

The second stept is to conditon the password. The idea here is to allow infrastructure to do this step early (before sending the passwords to authentication servers).
The function of the conditioning is producing a constant length and effecitvely hiding the clear test password from following steps. It uses the hash function specified
by the symbolic name (SHA2-512 or SHA3-512).

This conditioning is well within the specification for PBKDF2, because the HMAC used requires to hash the key (which is the password in this case) with the hash function
if it is longer as the blocksize.

   conditionedBytes = hash(passwordBytes) // TODO: use HMAC instead?
   
.Stept 3: Iterated Hashing

The third step does the main work, iteratively applying the PBKDF2 with the hash. This is the same as $pbkdf2$ formats are using.

    saltBytes = generaterandombytes(saltlen)
	hLen = 64 // output length of hash for both variants

    DK = PBKDF( // parameters see http://www.ietf.org/rfc/rfc2898.txt
      PRF = HMAC-SHA2-512 or HMAC-SHA3-512,
      P = conditionedBytes,
      S = saltBytes,
	  c = t, // iteration count
	  dkLen = hLen)
	
	// l = 1; r = 0

NB: iteratively applying Hmacs with SHA-2 can be optimized by precomputing the initial compression function on (K x iPad) and (K x oPad). This method is well
known to attackers and as a defender you  need to use this optimization as well. This format does not modify the PBKDF2 construct to make it impossible
because it explicitely wants to implement the standard. SHA3 does not use a Merkle-Damgard construction and prevents this shortcut.
	  
.Step 4: Sealing (Peppering)

The next step is optional: if a secret (pepper) is specified it will be used to run another round of HMAC with the given key. This step is only invoked once,
so it can be executed by a relative slow HSM or TPM.

    pepperBytes = read key wit keyid, should be hLen bytes
    sealedBytes = HMAC(key=pepperBytes, DK)
	
.Stept 5: Output Formatting

The result will be serialized in PHC format with the following method:

    truncLen = 32 // 12 .. 64
    hashBytes = truncate(sealedBytes, truncLen) // or DK if step 5 is skipped

	functionid = "pbkdf2s2" or "pbkdf2s3"

	param1 = (t!=20000) ? "t=" + t : ""
	param2 = (keyid!=null) ? "keyid=" + B64(keyid) : ""
	if (param1 != "" || param2 != "")
	  param = "§"
	  if (param1 != "")
	    param += param1
	    if (param2 != "")
		  param += "," + param2
	  else
	    if (param2 != "")
		  param += param2

	hashString = funtionid + param + "$" + B64(salt) + "$" + B64(hashBytes)
	
When parsing the PHC format to verify the salt and the sealed bytes get base64 parsed and length validated.
