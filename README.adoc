= Habibi a PBKDF2 based password hash format
Bernd Eckenfels
v0.1, 2017-03-19
:description: Draf Specification for a password hashing format based on PBKDF2 with conditioning and peppering.
:!compat-mode:
:keywords: password-hash, security, specification, PBKDF2, HMAC, SHA-3, SHA-3
:page-description: {description}
:page-keywords: {keywords}
:icons: font
:idprefix:
:idseparator:
:sectanchors:
:mdash: &#8212;

{description}

.Draft
****
This document is only a draft.
These recommendations are not doctrine and are subject to change.
Sent your comments to bernd-2017 (@) eckenfels.net*
****

== Introduction

Password hashes based on PBKDF2 are still in high demand.
The main reason for this is, that NIST endorses PBKDF2 with HMAC and endorsed hash function in SP 800-132 as well as the draft for the upcoming NIST Special Publication 800-63B _Digital Identity Guidelines: Authentication and Lifecycle Management_ (which is not very clear on the details but asks for aproved hashes and seperately stored secrets).

This repository collects the definition for a interoperable password hash format based on PBKDF2.
The format is intentionally restricted in variations as it can easily be replaced by a new prefix instead of making the parsing and generation too complex.

=== Alternatives

There are many advanced password hashing schemes out there, this specification does not try to compete.
If you are looking for a memory-hard alternative you are much better off with https://www.tarsnap.com/scrypt.html[_scrypt_] or https://password-hashing.net/#argon2[_ARGON2_].
If you look for a alternative with a wide range of operating system support https://en.wikipedia.org/wiki/Bcrypt[_bcrypt_] is probably your friend, since none of the normal password hashing schemes supported by unixoide `crypt()` have a comparable resistance against brute-forcing.
However if you care for approved cryptographic methods and some form of standards endoresement, then _PBKDF2_ is probably your best friend.

=== Password Securiy

The fact that this is a pretty current specification is by no means an endorsemet for password based authentication.
Memorized secets have all kinds of issues in practice wich makes them a huge security problem.
So consider alternatives or multple factors if you care for the security of your service and your users.
However since passwords cannot fully be avoided, you at least should store them with some level of protection.

Password hashing can not defend about overly weak passwords.
You should enfore a minimum complexity aproperiate for your service.
Since you are here for the conformance to NIST you should go all the way and follow the new _Special Publication 800-63-3: Digital Authentication Guidelines and related documents_: minimum length of passwords should be 8 ASCII or Unicode characters with no composition rules.
You can read this https://www.cisoadvisory.com/cai-blog/2016/10/24/nist-proposes-new-approach-to-passwords[summary].
Make sure to check for dictionary passwords.

== Properties of this Scheme 

* Uses PBKDF2 (https://tools.ietf.org/html/rfc2898#section-5.2[RFC 2898]) with HMac (https://tools.ietf.org/html/rfc2104[RFC 2104])
** Specifies a variant with SHA2-512 (FIPS 180-4 Section 6.2 - 6.5, https://tools.ietf.org/html/rfc6234[RFC 6234])
** Specifies a variant with SHA3-512 (FIPS 202)
* Supports variable number of iterations, salt bytes and output bytes
* Requires UTF-8 encoding
* Features a pre-conditioning step
* Allows for pepper (seperately stored key)

== Preconditioning

In a distributed system with front-end servers and authenticated servers it is useful if some protections of the password can be done early.
If this does not require a salt to be known/retrieved or access to hardware-secured secrets then this a win.
It also means the early erradication of clear-text (even in memory) opens a number of new applications like cashing the password checking outcome.
The later is especially good in environments where stateless services (with tokens or re-authentication) is used.

In the current draft the underlying hash function is used, as this blends well into the normal preconditioning required for HMAC keys which are longer than the blocksize.
However this is up for discusion: should a faster/different method be used?
(Facebook seems to use a MD5 hash as the outer layer of their password protection).
Using a fast and simple hash like MD5 has the advantage that it could be done even in Javascript.

== String Format 

    SHA2-512: $pbkdf2s2$[t=rrr][,keyid=kkkk]$ssssss$hhhhhhhhhhhhhhhh
    SHA3-512: $pbkdf2s3$[t=rrr][,keyid=kkkk]$ssssss$hhhhhhhhhhhhhhhh

The syntax uses the https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md[PHC string format] with two _function symbolic names_ (maximum 10 chars allowed):

* "pbkdf2s2": For a PBKDF2 based on HMac with SHA2-512 with conditioning and optional pepper
* "pbkdf2s3": For a PBKDF2 based on Hmac with SHA3-512 with conditioning and optional pepper

The parameters supported for the format are (in this order):

* t: Number of iterations, between 100 and (2^32)-1. Value is an integer in decimal, over 3 to 10 digits. The parameter is optional, the default value is 20000.
* keyid: Binary identifier for a key. Value is a sequence of 0 to 8 bytes, encoded in B64 as 0 to 11 characters. This parameter is optional; the default value means no key. 
  The contents of the identifier are chosen by the application and are meant to allow the application to locate the key to use for the pepper step.
 
The _salt_ is a B64 encoded. It supports salts in the range of 4-32 bytes (6-43 characters). By default a 16 byte salt should be generated. An encoded UUID, or a sequence
of 16 bytes produced with a cryptographically strong PRNG, are appropriate salt values.

The hash output is encoded in B64. Its length shall be between 12 and 64 bytes (16 and 86 characters, respectively). The default output length is 32 bytes (43 characters).
The validation step compares the given bytes starting from the left.

With this rules the total length of the password verifier is between 34 and 171 characters.

Using the prefix `{pbkdf2s2}` and `{pbkdf2s3}` instead of `$pbkdf2s2$` and `$pbkdf2s3ยง` is allowed in scenrios like LDAP attributes which prefer this syntax.

== Algorithm

.Step 1: Password to Bytes

The first function is to convert the text password into bytes. This must be done using the UTF-8 encoding. It should NOT remove consecutive blanks.
Leading and Trailing blanks must be removed. Implementations may reject passwords longer than 128 codepoints but should never silently truncate the input.
The implementation must reject passwords containing a NUL char (U+0000).

   passwordBytes = utf8encode(trim(passwordString))
  
TODO: Unicode Normalisation (NIST)?

.Step 2: Conditioning

The second stept is to conditon the password. The idea here is to allow infrastructure to do this step early (before sending the passwords to authentication servers).
The function of the conditioning is producing a constant length and effecitvely hiding the clear test password from following steps. It uses the hash function specified
by the symbolic name (SHA2-512 or SHA3-512).

This conditioning is well within the specification for PBKDF2, because the HMAC used requires to hash the key (which is the password in this case) with the hash function
if it is longer as the blocksize.

   conditionedBytes = hash(passwordBytes) // TODO: use HMAC instead?
   
.Stept 3: Iterated Hashing

The third step does the main work, iteratively applying the PBKDF2 with the hash. This is the same as $pbkdf2$ formats are using.

    saltBytes = generaterandombytes(saltlen)
	hLen = 64 // output length of hash for both variants

    DK = PBKDF( // parameters see http://www.ietf.org/rfc/rfc2898.txt
      PRF = HMAC-SHA2-512 or HMAC-SHA3-512,
      P = conditionedBytes,
      S = saltBytes,
	  c = t, // iteration count
	  dkLen = hLen)
	
	// l = 1; r = 0

NB: iteratively applying Hmacs with SHA-2 can be optimized by precomputing the initial compression function on (K x iPad) and (K x oPad). This method is well
known to attackers and as a defender you  need to use this optimization as well. This format does not modify the PBKDF2 construct to make it impossible
because it explicitely wants to implement the standard. SHA3 does not use a Merkle-Damgard construction and prevents this shortcut.
	  
.Step 4: Sealing (Peppering)

The next step is optional: if a secret (pepper) is specified it will be used to run another round of HMAC with the given key. This step is only invoked once,
so it can be executed by a relative slow HSM or TPM.

    pepperBytes = read key wit keyid, should be hLen bytes
    sealedBytes = HMAC(key=pepperBytes, DK)
	
.Stept 5: Output Formatting

The result will be serialized in PHC format with the following method:

    truncLen = 32 // 12 .. 64
    hashBytes = truncate(sealedBytes, truncLen) // or DK if step 5 is skipped

	functionid = "pbkdf2s2" or "pbkdf2s3"

	param1 = (t!=20000) ? "t=" + t : ""
	param2 = (keyid!=null) ? "keyid=" + B64(keyid) : ""
	if (param1 != "" || param2 != "")
	  param = "ยง"
	  if (param1 != "")
	    param += param1
	    if (param2 != "")
		  param += "," + param2
	  else
	    if (param2 != "")
		  param += param2

	hashString = funtionid + param + "$" + B64(salt) + "$" + B64(hashBytes)
	
When parsing the PHC format to verify the salt and the sealed bytes get base64 parsed and length validated.
